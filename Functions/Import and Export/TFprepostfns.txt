def preprocess(imgin):
    # Matlab does this interpolation slightly differently! (but this is now pretty close!)
    ImTF = tf.image.resize(imgin,size=(imgsize[0],imgsize[1]),method='bicubic',antialias=True)
    normImTF = (ImTF-np.min(ImTF))/(np.max(ImTF)-np.min(ImTF))
    imgout = np.reshape(normImTF,(1,normImTF.shape[0],normImTF.shape[1],normImTF.shape[2]))
    return imgout

def postprocess(score_tf,insize):
    # Number of detection heads
    nDetHeads = len(score_tf)

    output = [None]*nDetHeads
    for idx in range(nDetHeads):
        numTilesD1 = score_tf[idx].shape[1]
        numTilesD2= score_tf[idx].shape[2]
        numChannelsPred = score_tf[idx].shape[3]
        numAnchors = anchorBoxes[idx].shape[0]
        numPredElemsPerAnchors = int(numChannelsPred/numAnchors)
        channelsPredIdx = np.array(range(numChannelsPred))

        stride = numPredElemsPerAnchors
        endIdx = numChannelsPred-1

        # X positions.
        startIdx = 0
        xIds = range(startIdx,endIdx,stride)
        startIdx = 1
        yIds = range(startIdx,endIdx,stride)
        startIdx = 2
        wIds = range(startIdx,endIdx,stride)
        startIdx = 3
        hIds = range(startIdx,endIdx,stride)
        startIdx = 4
        cIds = range(startIdx,endIdx,stride)

        nonClassIds = np.array(list(xIds)+list(yIds)+list(wIds)+list(hIds)+list(cIds))
        dif1 = np.setdiff1d(channelsPredIdx, nonClassIds)
        dif2 = np.setdiff1d(nonClassIds, channelsPredIdx)
        ClassIds = np.concatenate((dif1, dif2))
        numClasses = int(ClassIds.shape[0]/numAnchors)
        
        predictions=[]
        for i in range(0,5):
            predictions.append(np.array([[[0.]*numAnchors]*numTilesD2]*numTilesD1))
        predictions.append(np.array([[[0.]*numAnchors*numClasses]*numTilesD2]*numTilesD1))
        for dim1 in range(numTilesD1):
            for dim2 in range(numTilesD2):
                nNewInd = 0
                for iAnch in xIds:
                    predictions[1][dim1][dim2][nNewInd] = tf.math.sigmoid(score_tf[idx][0][dim1][dim2][iAnch])
                    nNewInd = nNewInd+1
                nNewInd = 0
                for iAnch in yIds:
                    predictions[2][dim1][dim2][nNewInd] = tf.math.sigmoid(score_tf[idx][0][dim1][dim2][iAnch])
                    nNewInd = nNewInd+1
                nNewInd = 0
                for iAnch in wIds:
                    predictions[3][dim1][dim2][nNewInd] = tf.math.exp(score_tf[idx][0][dim1][dim2][iAnch])
                    nNewInd = nNewInd+1
                nNewInd = 0
                for iAnch in hIds:
                    predictions[4][dim1][dim2][nNewInd] = tf.math.exp(score_tf[idx][0][dim1][dim2][iAnch])
                    nNewInd = nNewInd+1
                nNewInd = 0
                for iAnch in cIds:
                    predictions[0][dim1][dim2][nNewInd] = tf.math.sigmoid(score_tf[idx][0][dim1][dim2][iAnch])
                    nNewInd = nNewInd+1
                nNewInd = 0
                for iAnch in ClassIds:
                    predictions[5][dim1][dim2][nNewInd] = tf.math.sigmoid(score_tf[idx][0][dim1][dim2][iAnch])
                    nNewInd = nNewInd+1
        output[idx] = predictions

    tiledAnchors = [None]*nDetHeads
    for idx in range(nDetHeads):
        h = output[idx][0].shape[0]
        w = output[idx][0].shape[1]
        n = anchorBoxes[idx].shape[0]
        thisidxTA = np.array([[[[0.]*n]*w]*h]*4)
        anchors = anchorBoxes[idx]
        for dim1 in range(h):
            for dim2 in range(w):
                for iAnch in range(n):
                    thisidxTA[0][dim1][dim2][iAnch] = dim2
                    thisidxTA[1][dim1][dim2][iAnch] = dim1
                    thisidxTA[2][dim1][dim2][iAnch] = anchors[iAnch][1]
                    thisidxTA[3][dim1][dim2][iAnch] = anchors[iAnch][0]
        tiledAnchors[idx] = thisidxTA

    for idx in range(nDetHeads):
        h = output[idx][0].shape[0]
        w = output[idx][0].shape[1]
        n = anchorBoxes[idx].shape[0]
        for dim1 in range(h):
            for dim2 in range(w):
                for iAnch in range(n):
                    tiledAnchors[idx][0][dim1][dim2][iAnch] = (tiledAnchors[idx][0][dim1][dim2][iAnch] + output[idx][1][dim1][dim2][iAnch])/w
                    tiledAnchors[idx][1][dim1][dim2][iAnch] = (tiledAnchors[idx][1][dim1][dim2][iAnch] + output[idx][2][dim1][dim2][iAnch])/h
                    tiledAnchors[idx][2][dim1][dim2][iAnch] = (tiledAnchors[idx][2][dim1][dim2][iAnch] * output[idx][3][dim1][dim2][iAnch])/imgsize[1]
                    tiledAnchors[idx][3][dim1][dim2][iAnch] = (tiledAnchors[idx][3][dim1][dim2][iAnch] * output[idx][4][dim1][dim2][iAnch])/imgsize[0]

    detections = [None]*nDetHeads
    for idx in range(nDetHeads):
        h = output[idx][0].shape[0]
        w = output[idx][0].shape[1]
        n = anchorBoxes[idx].shape[0]
        #thisidxdet = np.array([[0.]*h*w*n]*6)
        thisidxdet=[]
        for i in range(0,5):
            thisidxdet.append(np.array([0.]*h*w*n))
        thisidxdet.append(np.array([[0.]*h*w*n]*numClasses))
        for ncol in range(6):
            if (ncol == 0):
                thisidxdet[ncol] = np.reshape(output[idx][ncol],h*w*n,order='F')
            elif (ncol < 5):
                thisidxdet[ncol] = np.reshape(tiledAnchors[idx][ncol-1],h*w*n,order='F')
            else:
                if (numClasses > 1):
                    permx = np.reshape(output[idx][ncol],(h*w,numClasses,n),order='F')
                    permx = permx.transpose(0,2,1)
                    h = permx.shape[0]
                    w = permx.shape[1]
                    n = permx.shape[2]
                    thisidxdet[ncol] = np.reshape(permx,(h*w,n),order='F')
                else:
                    thisidxdet[ncol] = np.reshape(output[idx][ncol],h*w,order='F')
        detections[idx] = thisidxdet

    ccdets = np.array([None]*6)
    for idx in range(6):
        for iDH in range(nDetHeads):
            if (iDH==0):
                ccdets[idx] = detections[iDH][idx]
            else:
                ccdets[idx] = np.concatenate((ccdets[idx],detections[iDH][idx]),axis=0)

    classProbs = np.array([0.]*ccdets[5].shape[0])
    classIdx = np.array([0.]*ccdets[5].shape[0])
    for idx in range(classIdx.shape[0]):
        classProbs[idx] = np.max(ccdets[5][idx])
        classIdx[idx] = np.argmax(ccdets[5][idx])
    ccdets[0] = ccdets[0]*classProbs
    ccdets[5] = classIdx

    indKeep = ccdets[0]>=0.5
    scorePred = ccdets[0][indKeep]
    bboxesTmp = np.zeros((indKeep[indKeep].shape[0],4))
    bboxesTmp[:,0] = ccdets[1][indKeep]
    for idx in range(3):
        bboxesTmp[:,idx+1] = ccdets[idx+2][indKeep]
    classPred = ccdets[5][indKeep]

    inputImgSize1 = insize[0]
    inputImgSize2 = insize[1]
    scale = [inputImgSize2,inputImgSize1,inputImgSize2,inputImgSize1]
    bboxTmpSc = bboxesTmp*scale
    bboxTmpSc[:,0] = bboxTmpSc[:,0]-bboxTmpSc[:,2]/2 + 0.5
    bboxTmpSc[:,1] = bboxTmpSc[:,1]-bboxTmpSc[:,3]/2 + 0.5
    bboxTmpSc[bboxTmpSc<1] = 1

    # HERE WE SHOULD ELIMINATE THE LESSER (LOWER SCORE) OF ANY OVERLAPPING BBOXES WHERE THE OVERLAP IS >0.5
    #bboxTmpSc = bboxTmpSc[np.argsort(-scorePred),:]
    #classPred = classPred[np.argsort(-scorePred)]
    #scorePred = scorePred[np.argsort(-scorePred)]

    bboxes = bboxTmpSc
    scores = scorePred
    classes = classPred

    return bboxes,scores,classes